# ðŸ“± Frontend/Mobile App Integration Guide

**Version:** 1.0.0  
**Last Updated:** January 2025  
**Base URL:** `http://localhost:8000/api/v1` (Development)  
**Production URL:** `https://api.londarides.com/api/v1` (Production)

---

## ðŸ“‹ Table of Contents

1. [Overview](#overview)
2. [Setup & Configuration](#setup--configuration)
3. [Authentication Flow](#authentication-flow)
4. [API Client Implementation](#api-client-implementation)
5. [Error Handling](#error-handling)
6. [Common Patterns](#common-patterns)
7. [Best Practices](#best-practices)
8. [Platform-Specific Examples](#platform-specific-examples)

---

## Overview

This guide provides comprehensive instructions for integrating the Londa Rides API into mobile and web applications. The API uses Firebase Authentication with custom tokens, which must be exchanged for ID tokens on the client side before making authenticated requests.

### Key Concepts

- **Custom Token**: Generated by the API, includes custom claims for role-based access control
- **ID Token**: Generated by Firebase SDK after exchanging custom token, used for authenticated requests
- **User Types**: `user` (regular users) and `driver` (drivers only)
- **Authentication**: Bearer token in `Authorization` header
- **Response Format**: All responses follow a standard format with `success`, `message`, `data`, and `timestamp`

---

## Setup & Configuration

### Base URL Configuration

Configure the API base URL based on your environment:

```javascript
// React Native / JavaScript
const API_BASE_URL = __DEV__ 
  ? 'http://localhost:8000/api/v1'
  : 'https://api.londarides.com/api/v1';
```

```dart
// Flutter
const String apiBaseUrl = kDebugMode
    ? 'http://localhost:8000/api/v1'
    : 'https://api.londarides.com/api/v1';
```

```swift
// iOS Swift
let apiBaseUrl = Bundle.main.object(forInfoDictionaryKey: "API_BASE_URL") as? String 
    ?? "https://api.londarides.com/api/v1"
```

```kotlin
// Android Kotlin
val apiBaseUrl = if (BuildConfig.DEBUG) {
    "http://localhost:8000/api/v1"
} else {
    "https://api.londarides.com/api/v1"
}
```

### Firebase SDK Setup

Install and configure Firebase SDK for your platform:

**React Native:**
```bash
npm install @react-native-firebase/app @react-native-firebase/auth
```

**Flutter:**
```yaml
dependencies:
  firebase_core: ^2.24.0
  firebase_auth: ^4.15.0
```

**iOS (Swift):**
Add Firebase via CocoaPods or Swift Package Manager

**Android (Kotlin):**
Add Firebase via Gradle

---

## Authentication Flow

### Step-by-Step Authentication Process

#### 1. User Registration/Login Flow

**Step 1: Send OTP**
```javascript
// React Native Example
const response = await fetch(`${API_BASE_URL}/registration`, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    phone_number: '+264813442530'
  })
});

const data = await response.json();
const sessionInfo = data.data.sessionInfo; // Save this
```

**Step 2: Verify OTP and Get Custom Token**
```javascript
const response = await fetch(`${API_BASE_URL}/verify-otp`, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    phone_number: '+264813442530',
    otp: '123456',
    sessionInfo: sessionInfo
  })
});

const data = await response.json();
const customToken = data.data.accessToken; // This is a Firebase Custom Token
```

**Step 3: Exchange Custom Token for ID Token (Firebase SDK)**
```javascript
// React Native with @react-native-firebase/auth
import auth from '@react-native-firebase/auth';

try {
  // Sign in with custom token
  const userCredential = await auth().signInWithCustomToken(customToken);
  
  // Get ID token
  const idToken = await userCredential.user.getIdToken();
  
  // Save ID token securely
  await SecureStore.setItemAsync('auth_token', idToken);
  
  // Save user info
  await SecureStore.setItemAsync('user_id', userCredential.user.uid);
} catch (error) {
  console.error('Token exchange failed:', error);
}
```

**Step 4: Create Account (Optional)**
```javascript
const idToken = await SecureStore.getItemAsync('auth_token');

const response = await fetch(`${API_BASE_URL}/create-account`, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${idToken}`
  },
  body: JSON.stringify({
    phone_number: '+264813442530',
    email: 'user@example.com',
    name: 'John Doe',
    userType: 'student' // 'student', 'worker', or 'parent'
  })
});
```

#### 2. Driver Registration/Login Flow

The driver flow is similar but uses different endpoints:

**Step 1: Send Driver OTP**
```javascript
const response = await fetch(`${API_BASE_URL}/driver/send-otp`, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    phone_number: '+264813442530'
  })
});
```

**Step 2: Verify Driver OTP**
```javascript
const response = await fetch(`${API_BASE_URL}/driver/verify-otp`, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    phone_number: '+264813442530',
    otp: '123456',
    sessionInfo: sessionInfo
  })
});

const customToken = data.data.accessToken;
// Exchange for ID token (same as user flow)
```

**Step 3: Create Driver Account**
```javascript
const response = await fetch(`${API_BASE_URL}/driver/create-account`, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${idToken}`
  },
  body: JSON.stringify({
    phone_number: '+264813442530',
    email: 'driver@example.com',
    name: 'Driver Name',
    license_number: 'DL123456',
    vehicle_model: 'Toyota Corolla',
    vehicle_plate: 'ABC-123',
    vehicle_color: 'White'
  })
});
```

#### 3. Token Refresh

Tokens expire after 1 hour. Implement automatic token refresh:

```javascript
// React Native
import auth from '@react-native-firebase/auth';

async function refreshToken() {
  try {
    const currentUser = auth().currentUser;
    if (!currentUser) {
      throw new Error('No authenticated user');
    }
    
    // Get fresh ID token
    const idToken = await currentUser.getIdToken(true); // Force refresh
    await SecureStore.setItemAsync('auth_token', idToken);
    return idToken;
  } catch (error) {
    // If Firebase refresh fails, use API refresh endpoint
    const oldToken = await SecureStore.getItemAsync('auth_token');
    
    const response = await fetch(`${API_BASE_URL}/refresh-token`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${oldToken}`
      }
    });
    
    const data = await response.json();
    const newCustomToken = data.data.accessToken;
    
    // Exchange new custom token for ID token
    const userCredential = await auth().signInWithCustomToken(newCustomToken);
    const newIdToken = await userCredential.user.getIdToken();
    await SecureStore.setItemAsync('auth_token', newIdToken);
    return newIdToken;
  }
}
```

---

## API Client Implementation

### React Native (JavaScript/TypeScript)

```typescript
// apiClient.ts
import axios from 'axios';
import * as SecureStore from 'expo-secure-store';
import auth from '@react-native-firebase/auth';

const API_BASE_URL = __DEV__ 
  ? 'http://localhost:8000/api/v1'
  : 'https://api.londarides.com/api/v1';

// Create axios instance
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor - Add auth token
apiClient.interceptors.request.use(
  async (config) => {
    try {
      // Try to get ID token from Firebase
      const currentUser = auth().currentUser;
      if (currentUser) {
        const idToken = await currentUser.getIdToken();
        config.headers.Authorization = `Bearer ${idToken}`;
      } else {
        // Fallback to stored token
        const token = await SecureStore.getItemAsync('auth_token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
      }
    } catch (error) {
      console.error('Error getting auth token:', error);
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor - Handle errors and token refresh
apiClient.interceptors.response.use(
  (response) => {
    // Standardize response format
    return response.data;
  },
  async (error) => {
    const originalRequest = error.config;

    // Handle 401 Unauthorized - Token expired
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        // Refresh token
        const currentUser = auth().currentUser;
        if (currentUser) {
          const newToken = await currentUser.getIdToken(true);
          originalRequest.headers.Authorization = `Bearer ${newToken}`;
          return apiClient(originalRequest);
        }
      } catch (refreshError) {
        // Refresh failed - redirect to login
        console.error('Token refresh failed:', refreshError);
        // Navigate to login screen
        return Promise.reject(refreshError);
      }
    }

    // Handle other errors
    return Promise.reject(error);
  }
);

// API Methods
export const userAPI = {
  // Authentication
  register: (phoneNumber: string) =>
    apiClient.post('/registration', { phone_number: phoneNumber }),
  
  verifyOTP: (phoneNumber: string, otp: string, sessionInfo?: string) =>
    apiClient.post('/verify-otp', {
      phone_number: phoneNumber,
      otp,
      sessionInfo,
    }),
  
  createAccount: (data: {
    phone_number: string;
    email?: string;
    name: string;
    userType: 'student' | 'worker' | 'parent';
  }) => apiClient.post('/create-account', data),
  
  // Profile
  getProfile: () => apiClient.get('/me'),
  
  updateProfile: (data: { name?: string; email?: string }) =>
    apiClient.put('/update-profile', data),
  
  // Rides
  requestRide: (data: {
    pickup_location: Location;
    dropoff_location: Location;
    ride_type?: string;
    estimated_fare?: number;
    passengerCount?: number;
  }) => apiClient.post('/request-ride', data),
  
  getRides: (page: number = 1, limit: number = 10) =>
    apiClient.get('/get-rides', { params: { page, limit } }),
  
  cancelRide: (rideId: string, reason?: string) =>
    apiClient.post('/cancel-ride', { ride_id: rideId, reason }),
};

export default apiClient;
```

### Flutter (Dart)

```dart
// api_client.dart
import 'package:dio/dio.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class ApiClient {
  static const String baseUrl = 'https://api.londarides.com/api/v1';
  late Dio _dio;
  final FlutterSecureStorage _storage = const FlutterSecureStorage();
  final FirebaseAuth _auth = FirebaseAuth.instance;

  ApiClient() {
    _dio = Dio(BaseOptions(
      baseUrl: baseUrl,
      connectTimeout: const Duration(seconds: 30),
      receiveTimeout: const Duration(seconds: 30),
      headers: {
        'Content-Type': 'application/json',
      },
    ));

    // Request interceptor
    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) async {
        // Add auth token
        try {
          final user = _auth.currentUser;
          if (user != null) {
            final idToken = await user.getIdToken();
            options.headers['Authorization'] = 'Bearer $idToken';
          } else {
            final token = await _storage.read(key: 'auth_token');
            if (token != null) {
              options.headers['Authorization'] = 'Bearer $token';
            }
          }
        } catch (e) {
          print('Error getting auth token: $e');
        }
        return handler.next(options);
      },
      onError: (error, handler) async {
        // Handle 401 - Token expired
        if (error.response?.statusCode == 401) {
          try {
            final user = _auth.currentUser;
            if (user != null) {
              final newToken = await user.getIdToken(true);
              error.requestOptions.headers['Authorization'] = 'Bearer $newToken';
              return handler.resolve(await _dio.fetch(error.requestOptions));
            }
          } catch (e) {
            print('Token refresh failed: $e');
          }
        }
        return handler.next(error);
      },
    ));
  }

  // API Methods
  Future<Response> register(String phoneNumber) async {
    return await _dio.post('/registration', data: {
      'phone_number': phoneNumber,
    });
  }

  Future<Response> verifyOTP(String phoneNumber, String otp, {String? sessionInfo}) async {
    return await _dio.post('/verify-otp', data: {
      'phone_number': phoneNumber,
      'otp': otp,
      if (sessionInfo != null) 'sessionInfo': sessionInfo,
    });
  }

  Future<Response> createAccount({
    required String phoneNumber,
    String? email,
    required String name,
    required String userType,
  }) async {
    return await _dio.post('/create-account', data: {
      'phone_number': phoneNumber,
      if (email != null) 'email': email,
      'name': name,
      'userType': userType,
    });
  }

  Future<Response> getProfile() async {
    return await _dio.get('/me');
  }

  Future<Response> requestRide({
    required Map<String, dynamic> pickupLocation,
    required Map<String, dynamic> dropoffLocation,
    String? rideType,
    double? estimatedFare,
    int? passengerCount,
  }) async {
    return await _dio.post('/request-ride', data: {
      'pickup_location': pickupLocation,
      'dropoff_location': dropoffLocation,
      if (rideType != null) 'ride_type': rideType,
      if (estimatedFare != null) 'estimated_fare': estimatedFare,
      if (passengerCount != null) 'passengerCount': passengerCount,
    });
  }
}
```

### iOS (Swift)

```swift
// APIClient.swift
import Foundation
import FirebaseAuth

class APIClient {
    static let shared = APIClient()
    private let baseURL = "https://api.londarides.com/api/v1"
    
    private init() {}
    
    private func getAuthToken() async throws -> String? {
        guard let user = Auth.auth().currentUser else {
            return nil
        }
        return try await user.getIDToken()
    }
    
    private func makeRequest(
        method: String,
        endpoint: String,
        body: [String: Any]? = nil
    ) async throws -> [String: Any] {
        guard let url = URL(string: "\(baseURL)\(endpoint)") else {
            throw APIError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = method
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Add auth token
        if let token = try await getAuthToken() {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        
        // Add body
        if let body = body {
            request.httpBody = try JSONSerialization.data(withJSONObject: body)
        }
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw APIError.invalidResponse
        }
        
        // Handle 401 - Token expired
        if httpResponse.statusCode == 401 {
            // Refresh token and retry
            if let user = Auth.auth().currentUser {
                let newToken = try await user.getIDToken(forcingRefresh: true)
                request.setValue("Bearer \(newToken)", forHTTPHeaderField: "Authorization")
                let (retryData, _) = try await URLSession.shared.data(for: request)
                return try JSONSerialization.jsonObject(with: retryData) as! [String: Any]
            }
        }
        
        guard (200...299).contains(httpResponse.statusCode) else {
            throw APIError.httpError(httpResponse.statusCode)
        }
        
        return try JSONSerialization.jsonObject(with: data) as! [String: Any]
    }
    
    // API Methods
    func register(phoneNumber: String) async throws -> [String: Any] {
        return try await makeRequest(
            method: "POST",
            endpoint: "/registration",
            body: ["phone_number": phoneNumber]
        )
    }
    
    func verifyOTP(phoneNumber: String, otp: String, sessionInfo: String?) async throws -> [String: Any] {
        var body: [String: Any] = [
            "phone_number": phoneNumber,
            "otp": otp
        ]
        if let sessionInfo = sessionInfo {
            body["sessionInfo"] = sessionInfo
        }
        return try await makeRequest(
            method: "POST",
            endpoint: "/verify-otp",
            body: body
        )
    }
    
    func getProfile() async throws -> [String: Any] {
        return try await makeRequest(method: "GET", endpoint: "/me")
    }
}
```

### Android (Kotlin)

```kotlin
// ApiClient.kt
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import com.google.firebase.auth.FirebaseAuth
import org.json.JSONObject
import kotlinx.coroutines.tasks.await

class ApiClient {
    private val baseUrl = "https://api.londarides.com/api/v1"
    private val client = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .build()
    private val auth = FirebaseAuth.getInstance()
    
    private suspend fun getAuthToken(): String? {
        return auth.currentUser?.getIdToken(false)?.await()?.token
    }
    
    private suspend fun makeRequest(
        method: String,
        endpoint: String,
        body: JSONObject? = null
    ): JSONObject {
        val url = "$baseUrl$endpoint"
        val requestBuilder = Request.Builder().url(url)
        
        // Add auth token
        val token = getAuthToken()
        if (token != null) {
            requestBuilder.addHeader("Authorization", "Bearer $token")
        }
        
        // Add body
        if (body != null) {
            val mediaType = "application/json".toMediaType()
            val requestBody = body.toString().toRequestBody(mediaType)
            requestBuilder.method(method, requestBody)
        } else {
            requestBuilder.method(method, null)
        }
        
        val request = requestBuilder.build()
        val response = client.newCall(request).execute()
        
        // Handle 401 - Token expired
        if (response.code == 401) {
            val newToken = auth.currentUser?.getIdToken(true)?.await()?.token
            if (newToken != null) {
                val retryRequest = request.newBuilder()
                    .header("Authorization", "Bearer $newToken")
                    .build()
                val retryResponse = client.newCall(retryRequest).execute()
                return JSONObject(retryResponse.body?.string() ?: "{}")
            }
        }
        
        if (!response.isSuccessful) {
            throw Exception("HTTP ${response.code}: ${response.message}")
        }
        
        val responseBody = response.body?.string() ?: "{}"
        return JSONObject(responseBody)
    }
    
    // API Methods
    suspend fun register(phoneNumber: String): JSONObject {
        val body = JSONObject().apply {
            put("phone_number", phoneNumber)
        }
        return makeRequest("POST", "/registration", body)
    }
    
    suspend fun verifyOTP(phoneNumber: String, otp: String, sessionInfo: String?): JSONObject {
        val body = JSONObject().apply {
            put("phone_number", phoneNumber)
            put("otp", otp)
            if (sessionInfo != null) put("sessionInfo", sessionInfo)
        }
        return makeRequest("POST", "/verify-otp", body)
    }
    
    suspend fun getProfile(): JSONObject {
        return makeRequest("GET", "/me")
    }
}
```

---

## Error Handling

### Standard Error Response Format

All error responses follow this format:

```json
{
  "success": false,
  "message": "Error description",
  "error": {
    "code": "ERROR_CODE",
    "details": {}
  },
  "timestamp": "2025-01-01T00:00:00.000000"
}
```

### HTTP Status Codes

- **200 OK**: Request successful
- **201 Created**: Resource created successfully
- **400 Bad Request**: Invalid request data
- **401 Unauthorized**: Missing or invalid authentication token
- **403 Forbidden**: Insufficient permissions (e.g., user trying to access driver endpoint)
- **404 Not Found**: Resource not found
- **409 Conflict**: Resource already exists
- **500 Internal Server Error**: Server error

### Error Handling Implementation

```typescript
// React Native / TypeScript
interface APIError {
  success: false;
  message: string;
  error: {
    code: string;
    details: any;
  };
  timestamp: string;
}

async function handleAPIError(error: any): Promise<never> {
  if (error.response) {
    // API returned error response
    const apiError: APIError = error.response.data;
    
    switch (error.response.status) {
      case 401:
        // Token expired - refresh or redirect to login
        await refreshToken();
        throw new Error('Please try again');
      case 403:
        // Forbidden - user doesn't have permission
        throw new Error('You do not have permission to perform this action');
      case 404:
        throw new Error('Resource not found');
      case 409:
        throw new Error(apiError.message || 'Resource already exists');
      default:
        throw new Error(apiError.message || 'An error occurred');
    }
  } else if (error.request) {
    // Request made but no response
    throw new Error('Network error. Please check your connection.');
  } else {
    // Error setting up request
    throw new Error('Request failed. Please try again.');
  }
}
```

---

## Common Patterns

### Making Authenticated Requests

```typescript
// Always include Authorization header
const response = await apiClient.get('/me', {
  headers: {
    'Authorization': `Bearer ${idToken}`
  }
});
```

### Handling Pagination

```typescript
interface PaginatedResponse<T> {
  data: {
    items: T[];
    total: number;
    page: number;
    limit: number;
    hasMore: boolean;
  };
}

async function getRides(page: number = 1): Promise<PaginatedResponse<Ride>> {
  const response = await apiClient.get('/get-rides', {
    params: { page, limit: 10 }
  });
  return response.data;
}
```

### Parsing Standard Response Format

```typescript
interface APIResponse<T> {
  success: boolean;
  message: string;
  data?: T;
  timestamp: string;
}

function parseResponse<T>(response: APIResponse<T>): T {
  if (!response.success) {
    throw new Error(response.message);
  }
  if (!response.data) {
    throw new Error('No data in response');
  }
  return response.data;
}

// Usage
const userData = parseResponse(await apiClient.get('/me'));
```

---

## Best Practices

### 1. Token Security

- âœ… **DO**: Store tokens in secure storage (Keychain, SecureStore, EncryptedSharedPreferences)
- âœ… **DO**: Never log tokens in production
- âœ… **DO**: Refresh tokens before expiration
- âŒ **DON'T**: Store tokens in plain text or localStorage
- âŒ **DON'T**: Include tokens in error logs

### 2. Request Interceptors

Always use request interceptors to automatically add auth tokens:

```typescript
apiClient.interceptors.request.use(async (config) => {
  const token = await getAuthToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
```

### 3. Response Interceptors

Handle token expiration automatically:

```typescript
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      // Refresh token and retry
      await refreshToken();
      return apiClient.request(error.config);
    }
    return Promise.reject(error);
  }
);
```

### 4. Error Recovery

Implement retry logic for network errors:

```typescript
async function retryRequest<T>(
  request: () => Promise<T>,
  maxRetries: number = 3
): Promise<T> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await request();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
  throw new Error('Max retries exceeded');
}
```

### 5. Offline Support

Cache responses and handle offline scenarios:

```typescript
import AsyncStorage from '@react-native-async-storage/async-storage';

async function getCachedOrFetch<T>(
  key: string,
  fetchFn: () => Promise<T>,
  ttl: number = 5 * 60 * 1000 // 5 minutes
): Promise<T> {
  try {
    // Try to fetch fresh data
    const data = await fetchFn();
    await AsyncStorage.setItem(key, JSON.stringify({
      data,
      timestamp: Date.now()
    }));
    return data;
  } catch (error) {
    // If fetch fails, try cache
    const cached = await AsyncStorage.getItem(key);
    if (cached) {
      const { data, timestamp } = JSON.parse(cached);
      if (Date.now() - timestamp < ttl) {
        return data;
      }
    }
    throw error;
  }
}
```

---

## Platform-Specific Examples

### Complete React Native Example

See the full React Native implementation in the [API Client Implementation](#api-client-implementation) section above.

### Complete Flutter Example

See the full Flutter implementation in the [API Client Implementation](#api-client-implementation) section above.

### Complete iOS Example

See the full iOS Swift implementation in the [API Client Implementation](#api-client-implementation) section above.

### Complete Android Example

See the full Android Kotlin implementation in the [API Client Implementation](#api-client-implementation) section above.

---

## Additional Resources

- [Firebase Authentication Documentation](https://firebase.google.com/docs/auth)
- [API Documentation](./API_DOCUMENTATION.md)
- [Authentication Flow Guide](./AUTHENTICATION_FLOW_GUIDE.md)
- [Postman Collection](./postmancollection/Londa_Rides_API_Collection_Complete.postman_collection.json)

---

**Need Help?**  
If you encounter any issues integrating the API, please refer to the main [API Documentation](./API_DOCUMENTATION.md) or contact the development team.

